local hex_size = 128
local boardwidth = 15
local boardheight = 8
local extrawidth = 10
local extraheight = 10
local wood_score = 0
local water_score = 0
local wood_income = 0
local water_income = 0
local bonus_limit = 6
local income = 0
local bonus = 0

local tile_types = { hash("green"),hash("green"),hash("green"),hash("green"),hash("green"), 
	hash("blue"),hash("blue"),hash("blue"), hash("wood"), hash("wood"), hash("wood") }
local darkness_size = 2
local darkness_begin = 0
					
function init(self)
	msg.post(".", "acquire_input_focus")
	self.board = new_board()
	
end

function check_coord(x, y)
	if (x >= boardwidth or x < 0 or y < 0 or y >= boardheight) then
		return false
	end
	return true
end

function dfs(self, used, x, y, type) 
	used[x][y] = 1
	if income > 0 and bonus < bonus_limit then 
		bonus = bonus + 1
	end
	income = income + 1
	if check_coord(x, y) and y % 2 == 0 then
		if check_coord(x - 1, y) and used[x-1][y] == 0 and self.board[x-1][y].tile_type == type then
			dfs(self, used, x - 1, y, type)
		end
		if check_coord(x + 1, y) and used[x+1][y] == 0 and self.board[x+1][y].tile_type == type then
			dfs(self, used, x + 1, y, type)
		end
		if check_coord(x - 1, y + 1) and used[x-1][y+1] == 0 and self.board[x-1][y+1].tile_type == type then
			dfs(self, used, x - 1, y + 1, type)
		end
		if check_coord(x, y + 1) and used[x][y+1] == 0 and self.board[x][y+1].tile_type == type then
			dfs(self, used, x, y + 1, type)
		end
		if check_coord(x - 1, y - 1) and used[x-1][y-1] == 0 and self.board[x-1][y-1].tile_type == type then
			dfs(self, used, x - 1, y - 1, type)
		end
		if check_coord(x, y - 1) and used[x][y-1] == 0 and self.board[x][y-1].tile_type == type then
			dfs(self, used, x, y - 1, type)
		end
	elseif check_coord(x, y)  and y % 2 == 1 then 
		if check_coord(x - 1, y) and used[x-1][y] == 0 and self.board[x-1][y].tile_type == type then
			dfs(self, used, x - 1, y, type)
		end
		if check_coord(x + 1, y) and used[x+1][y] == 0 and self.board[x+1][y].tile_type == type then
			dfs(self, used, x + 1, y, type)
		end
		if check_coord(x + 1, y + 1) and used[x+1][y+1] == 0 and self.board[x+1][y+1].tile_type == type then
			dfs(self, used, x + 1, y + 1, type)
		end
		if check_coord(x, y + 1) and used[x][y+1] == 0 and self.board[x][y+1].tile_type == type then
			dfs(self, used, x, y + 1, type)
		end
		if check_coord(x, y - 1) and used[x][y-1] == 0 and self.board[x][y-1].tile_type == type then
			dfs(self, used, x, y - 1, type)
		end
		if check_coord(x + 1, y - 1) and used[x + 1][y-1] == 0 and self.board[x + 1][y-1].tile_type == type then
			dfs(self, used, x + 1, y - 1, type)
		end
	end
end

function tile_group(self, x, y, type)
	local used = {}
	for i = 0,boardwidth-1 do
		used[i] = {}
		for j = 0,boardheight-1 do
			used[i][j] = 0
		end
	end
	bonus = 0
	income = 0
	dfs(self, used, x, y, type)
	if type == hash("wood") then
		wood_income = bonus + income
	end
end

function score_calculation(self, new_type, old_type, x, y)
	tile_group(self, x, y, new_type)
	if new_type == hash("wood") then
		wood_score = wood_score + wood_income
		label.set_text("#score_wood", wood_score)
	end
	if old_type == hash("wood") then
		wood_score = wood_score - 1
		label.set_text("#score_wood", wood_score)
	end
end

function new_board()
	math.randomseed(os.time())
	local new_board = {}
	local tmp_board = {}
	local pos = vmath.vector3()
	local x = 0
	local y = 0
	tmp_board[0] = {}
	tmp_board[1] = {}
	
	for x = 0,boardwidth-1 do
		tmp_board[0][x] = {}
		tmp_board[1][x] = {}
		for y = 0,boardheight-1 do
			local tile_type = tile_types[math.random(#tile_types)]
			tmp_board[0][x][y] = {tile_type = tile_type}
			tmp_board[1][x][y] = {tile_type = tile_type}
		end
	end

	local iterations = 0
	
	for i = 0, iterations do
		for x = 1,boardwidth-2 do
			for y = 1,boardheight-2 do
				local close_green = 0
				if tmp_board[(i+1)%2][x+1][y].tile_type == hash("green") then
					close_green = close_green + 1
				end
				if tmp_board[(i+1)%2][x-1][y].tile_type == hash("green") then
					close_green = close_green + 1
				end
				if tmp_board[(i+1)%2][x][y+1].tile_type == hash("green") then
					close_green = close_green + 1
				end
				if tmp_board[(i+1)%2][x][y-1].tile_type == hash("green") then
					close_green = close_green + 1
				end
				local sdvig = -1 + (y%2)*2
				if tmp_board[(i+1)%2][x+sdvig][y+1].tile_type == hash("green") then
					close_green = close_green + 1
				end
				if tmp_board[(i+1)%2][x+sdvig][y-1].tile_type == hash("green") then
					close_green = close_green + 1
				end
				
				if close_green > 3 then
					tmp_board[i%2][x][y] = {tile_type = hash("green")}
				elseif close_green < 3 then
					tmp_board[i%2][x][y] = {tile_type = hash("blue")}
				else 
					tmp_board[i%2][x][y] = tmp_board[(i+1)%2][x][y]
				end
			end
		end
	end
	
	for x = 0,boardwidth-1 do
		pos.x = 64+hex_size*x +extrawidth
		new_board[x] = {}
		for y = 0,boardheight-1 do
			pos.y = 64+3*hex_size*y/4 +extraheight
			if y%2==1 then
				pos.x = pos.x + hex_size/2
			end
			local tile_type = tmp_board[iterations%2][x][y].tile_type
			local id_tile = factory.create("#hex_factory", pos, null, {tile_type = tile_type})
			new_board[x][y] = {id = id_tile, x = x, y = y, tile_pos_x = pos.x, tile_pos_y = pos.y, tile_type = tile_type}
			if y%2==1 then
				pos.x = pos.x - hex_size/2
			end


			
			pos.y = 64+3*hex_size*y/4+extraheight
			if y%2==1 then
				pos.x = pos.x + hex_size/2
			end

			pos.x = pos.x + hex_size/2
			pos.y = pos.y + hex_size/4
			--factory.create("#corner_point_factory", pos, null)
			pos.y = pos.y - hex_size/2
			factory.create("#corner_point_factory", pos, null)
			pos.x = pos.x - hex_size/2
			pos.y = pos.y - hex_size/4
			factory.create("#corner_point_factory", pos, null)
			pos.y = pos.y + hex_size/2
			if y%2==1 then
				pos.x = pos.x - hex_size/2
			end


			
		end
	end
	
	return new_board
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	if message_id == hash("move_darkness") then
		
		for y = 0, boardheight-1 do
			msg.post(self.board[darkness_begin][y].id, "go_light")
		end
		
		darkness_begin = (darkness_begin+1)%boardwidth
		for i = darkness_begin, darkness_begin+darkness_size-1 do
			for y = 0, boardheight-1 do
				msg.post(self.board[i][y].id, "go_dark")
			end
		end
	elseif message_id == hash("update_tile") then
		self.board[message.x][message.y].tile_type = message.new_type
		score_calculation(self, message.new_type, message.old_type, message.x, message.y)
	end
end

function return_hex_index_from_coords(self, x, y)
	local tmp_y = y - extraheight
	local tmp_x = x - extrawidth
	tmp_y = math.floor(tmp_y/(hex_size*3/4))
	tmp_x = math.floor(tmp_x/(hex_size))

	
	for i = (tmp_x - 1), tmp_x do
		for j = (tmp_y - 1), tmp_y do
			if i >= 0 and j >= 0 and i <= boardwidth-1 and j <= boardheight-1 then
				local pos_x = self.board[i][j].tile_pos_x
				local pos_y = self.board[i][j].tile_pos_y
				if ((pos_x-x)^2 + (pos_y-y)^2) <= (hex_size/2)^2 then
					return i, j
				end
			end
		end
	end
	
	return -1, -1
end

local score = 0

function on_input(self, action_id, action)
	if action_id == hash("touch_left") and action.pressed then
		local tile_x, tile_y = return_hex_index_from_coords(self, action.x, action.y)
		label.set_text("#score_x", tile_x)
		label.set_text("#score_y", tile_y)
		if tile_x >= 0 and tile_y >=0 then
			msg.post(self.board[tile_x][tile_y].id, "change_type", {x = tile_x, y = tile_y})
		else
			msg.post("#", "move_darkness")
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
