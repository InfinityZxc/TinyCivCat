local hex_size
go.property("hex_size", 128)
local boardwidth
go.property("boardwidth", 10)
local boardheight
go.property("boardheight", 9)
local extrawidth
go.property("extrawidth", 200)
local extraheight
go.property("extraheight", 100)
local initial_delay_cost = 70
local initial_uncorrupt_cost = 70
local delay_cost = 70
local uncorrupt_cost = 70
local ability_cost_increase = 10
local coins = 0
local coin_income = 0
local corruption_delay = 0
local start_hex_pos =  vmath.vector3(4,4,0)
local first_corruption_hex_pos = vmath.vector3(4,4,0)
local wood_score = 0
local water_score = 0
local rock_score = 0
local wood_income = 0
local water_income = 0
local rock_income = 0
local bonus_limit = 6
local income = 0
local bonus = 0
local turn_counter = 0
local moving_tile_id = nil
local moving_tile_offset = nil
local map_type = hash("hex")
go.property("map_type", hash("hex"))
local corruption_beginning = 15
local corruption_acceleration = 10
local unhash = {
	[hash("wood")] = "wood",
	[hash("rock")] = "rock",
	[hash("broken_rock")] = "broken_rock",
	[hash("water")] = "water"
}
local thunder = false
local thunder_active = false
local snow = false


function init(self)
	msg.post(".", "acquire_input_focus")
	defos.disable_window_resize()

	-- in case here are some settings that affect properties
	init_locals_from_properties("#")
	
	self.board = new_board()
	create_grid(self)
	
	score_calculation(self, hash("none"), hash("none"))
	timer.delay(0.8, false, function ()
		msg.post("/gui#main", "acquire_input_focus")
	end)
	msg.post("/gui#main", "gui_set_thunder_cost", {cost = uncorrupt_cost})
	msg.post("/gui#main", "gui_set_snow_cost", {cost = delay_cost})
end

function create_grid(self)
	self.grid = {}
	local pos = vmath.vector3()
	for x = 0,boardwidth-1 do
		pos.x = 64+hex_size*x +extrawidth
		self.grid[x] = {}
		for y = 0,boardheight-1 do
			if check_coord(x, y) then
				pos.y = 64+3*hex_size*y/4+extraheight
				if y%2==1 then
					pos.x = pos.x + hex_size/2
				end
				pos.z = 1 / (y + 3)
				pos.z = pos.z / 2
				local grid_id = nil
				factory.create("/game#boundaries_factory", pos, null)
				self.grid[x][y] = {id = grid_id}
				if y%2==1 then
					pos.x = pos.x - hex_size/2
				end
			end
		end
	end
end

function init_locals_from_properties(from_where)
	hex_size = go.get(from_where, "hex_size")
	boardwidth = go.get(from_where, "boardwidth")
	boardheight = go.get(from_where, "boardheight")
	extrawidth = go.get(from_where, "extrawidth")
	extraheight = go.get(from_where, "extraheight")
	map_type = go.get(from_where, "map_type")
end

function check_coord(x, y)
	if map_type == hash("hex") then
		-- looks a bit like hex(octagon actually, but we need more height), requires some rework, but you get the idea
		if (x >= boardwidth or x < 0 or y < 0 or y >= boardheight or
		x + y < 3 or math.abs(boardwidth - 1 - x) + y < 3 or
		x + math.abs(boardheight - 1 - y) < 3 or math.abs(boardwidth - 1 - x) + math.abs(boardheight - 1 - y) < 3 or 
		(y%2 == 0 and x == 0) or (y%2 == 1 and x == 9)) and
		not (x == 0 and y == 4) and 
		not (x == 1 and y == 1) and 
		not (x == 2 and y == 0) and 
		not (x == 1 and y == 7) and 
		not (x == 2 and y == 8) and 
		not (x == 7 and y == 8) and 
		not (x == 7 and y == 0)
		then
			return false
		end
		return true
	else
		if (x >= boardwidth or x < 0 or y < 0 or y >= boardheight) then
			return false
		end
		return true
	end
end

function is_hex_valid_dfs(self, used, x, y, type)
	return check_coord(x, y) and self.board[x][y].id and used[x][y] == 0 and self.board[x][y].tile_type == type and not self.board[x][y].corrupted
end

function spawn_coins(self, x, y, bonus_zero_one, type)
	if turn_counter > 0 and turn_counter < 4 then
		local pos = vmath.vector3(self.board[x][y].tile_pos_x, self.board[x][y].tile_pos_y, 1)
		local coins_needed = 0  -- maximum 10 or some will be invisible
		pos.z = pos.z - 0.1
		if type == hash("wood") then
			coins_needed = 3 + bonus_zero_one
		elseif type == hash("water") then
			coins_needed = 1 + 3 * bonus_zero_one
		elseif type == hash("rock") then
			coins_needed = 2 + 2 * bonus_zero_one
		end
		for coin_number = 1, coins_needed do
			local delay = coin_number * 3 / 10 -- + (((x + y) / 10) % 1) / 2
			pos.z = pos.z + 0.01
			timer.delay(delay, false, function ()
				factory.create("#coin_factory", pos, null)
			end)
		end
	elseif turn_counter >= 4 then
		local coins_needed = 0
		if type == hash("wood") then
			coins_needed = 3 + bonus_zero_one
		elseif type == hash("water") then
			coins_needed = 1 + 3 * bonus_zero_one
		elseif type == hash("rock") then
			coins_needed = 2 + 2 * bonus_zero_one
		end
		label.set_text(msg.url(nil, self.board[x][y].id, "production_label"), coins_needed)
	end
end

function dfs(self, used, x, y, type) 
	used[x][y] = 1
	if income > 0 and bonus < bonus_limit then 
		bonus = bonus + 1
		spawn_coins(self, x, y, 1, type);
	else
		spawn_coins(self, x, y, 0, type);
	end
	income = income + 1
	if check_coord(x, y) and y % 2 == 0 and not self.board[x][y].corrupted then
		if is_hex_valid_dfs(self, used, x-1, y, type) then
			dfs(self, used, x - 1, y, type)
		end
		if is_hex_valid_dfs(self, used, x+1, y, type) then
			dfs(self, used, x + 1, y, type)
		end
		if is_hex_valid_dfs(self, used, x-1, y + 1, type) then
			dfs(self, used, x - 1, y + 1, type)
		end
		if is_hex_valid_dfs(self, used, x, y + 1, type) then
			dfs(self, used, x, y + 1, type)
		end
		if is_hex_valid_dfs(self, used, x-1, y - 1, type) then
			dfs(self, used, x - 1, y - 1, type)
		end
		if is_hex_valid_dfs(self, used, x, y - 1, type) then
			dfs(self, used, x, y - 1, type)
		end
	elseif check_coord(x, y)  and y % 2 == 1 and not self.board[x][y].corrupted then 
		if is_hex_valid_dfs(self, used, x-1, y, type) then
			dfs(self, used, x - 1, y, type)
		end
		if is_hex_valid_dfs(self, used, x+1, y, type) then
			dfs(self, used, x + 1, y, type)
		end
		if is_hex_valid_dfs(self, used, x+1, y+1, type) then
			dfs(self, used, x + 1, y + 1, type)
		end
		if is_hex_valid_dfs(self, used, x, y+1, type) then
			dfs(self, used, x, y + 1, type)
		end
		if is_hex_valid_dfs(self, used, x, y-1, type) then
			dfs(self, used, x, y - 1, type)
		end
		if is_hex_valid_dfs(self, used, x+1, y-1, type) then
			dfs(self, used, x + 1, y - 1, type)
		end
	end
end

function tile_group(self, type)
	local used = {}
	for i = 0,boardwidth-1 do
		used[i] = {}
		for j = 0,boardheight-1 do
			used[i][j] = 0
		end
	end
	bonus = 0
	income = 0
	reset_income(type)
	for i = 0, boardwidth - 1 do 
		for j = 0, boardheight - 1 do
			if is_hex_valid_dfs(self, used, i, j, type)then
				dfs(self, used, i, j, type)
				update_income(type)
				bonus = 0
				income = 0
			end
		end
	end
end

function score_calculation(self, new_type, old_type)
	tile_group(self, hash("wood"))
	wood_score = wood_score + wood_income
	coin_income = wood_income
	tile_group(self, hash("water"))
	water_score = water_score + water_income
	coin_income = coin_income + water_income
	tile_group(self, hash("rock"))
	rock_score = rock_score + rock_income
	coin_income = coin_income + rock_income
	coins = coins + coin_income
	msg.post("/gui#main", "gui_set_coins", {coins = coins})
	msg.post("/gui#main", "gui_set_income", {income = coin_income})
end

function reset_income (type)
	if type == hash("wood") then
		wood_income = 0
	elseif type == hash("water") then
		water_income = 0
	elseif type == hash("rock") then
		rock_income = 0
	end
end

function update_income (type)
	if type == hash("wood") then
		wood_income = wood_income + 3 * income + bonus
	elseif type == hash("water") then
		water_income = water_income + income + 3 * bonus
	elseif type == hash("rock") then
		rock_income = rock_income + 2 * income + 2 * bonus
	end
end

function heal_cell(self, x, y)
	if (coins >= uncorrupt_cost) and self.board[x][y].corrupted then
		self.board[x][y].corrupted = false;
		msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = self.board[x][y].tile_type})
		score_calculation(self, hash("none"), hash("none"))
		coins = coins - coin_income
		coins = coins - uncorrupt_cost
		uncorrupt_cost = uncorrupt_cost + ability_cost_increase
		msg.post("/gui#main", "gui_set_thunder_cost", {cost = uncorrupt_cost})
		msg.post("/gui#main", "gui_set_snow_cost", {cost = delay_cost})
		msg.post("/gui#main", "gui_set_coins", {coins = coins})
		if not snow then
			if coins >= delay_cost then
				msg.post("/gui#main", "set_asset", {node_id = hash("snow"), anim_id = hash("snowflake")})
			else
				msg.post("/gui#main", "set_asset", {node_id = hash("snow"), anim_id = hash("snowflake_used")})
			end
		end
	end
end

function delay_corrupt(self)
	if coins >= delay_cost then
		snow = true
		corruption_delay = 1
		coins = coins - delay_cost
		delay_cost = delay_cost + ability_cost_increase
		msg.post("/gui#main", "gui_set_thunder_cost", {cost = uncorrupt_cost})
		msg.post("/gui#main", "gui_set_snow_cost", {cost = delay_cost})
		msg.post("/gui#main", "gui_set_coins", {coins = coins})
		msg.post("/gui#main", "set_asset", {node_id = hash("snow"), anim_id = hash("snowflake_active")})
		for x = 0,boardwidth-1 do
			for y = 0,boardheight-1 do
				if self.board[x][y].corrupted then
					local type = unhash[self.board[x][y].tile_type]
					if type == "rock" then
						type = "broken_rock"
					end
					msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("bugged_" .. type .. "-" .. math.random(1, 5))})
				end
			end
		end
		if not thunder then
			if coins >= uncorrupt_cost then
				msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder")})
			else
				msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder_used")})
			end
		end
	end
end

function new_board()
	math.randomseed(os.clock())
	local new_board = {}
	local pos = vmath.vector3()
	local x = 0
	local y = 0
	local starting_set = {hash("rock"), hash("wood")}
	for x = 0,boardwidth-1 do
		pos.x = 64+hex_size*x +extrawidth
		new_board[x] = {}
		for y = 0,boardheight-1 do
			pos.y = 64+3*hex_size*y/4 +extraheight
			if y%2==1 then
				pos.x = pos.x + hex_size/2
			end
			local tile_type = hash("rock")
			local id_tile
			--[[  for check_coord tests
			if check_coord(x, y) then
				id_tile = factory.create("#hex_factory", pos, null, {tile_type = tile_type})
			end 
			--]]
			if (x == start_hex_pos.x or x == start_hex_pos.x +1) and y ==  start_hex_pos.y then
				random_pick = math.random(#starting_set)
				tile_type = starting_set[random_pick]
				if tile_type == hash("wood") then
					first_corruption_hex_pos = vmath.vector3(x,y,0)
				end
				table.remove(starting_set, random_pick)
				pos.z = 1 / (y + 3)
				id_tile = factory.create("#hex_factory", pos, null, {tile_type = tile_type})
			else
				id_tile = nil
			end
			new_board[x][y] = {id = id_tile, x = x, y = y, tile_pos_x = pos.x, tile_pos_y = pos.y, tile_type = tile_type, corrupted = false}
			if y%2==1 then
				pos.x = pos.x - hex_size/2
			end
		end
	end
	return new_board
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function clear_corruption(self, completely)
	for x = 0,boardwidth-1 do
		for y = 0,boardheight-1 do
			if self.board[x][y].id then
				if completely then
					if self.board[x][y].corrupted then
						self.board[x][y].corrupted = false;
						msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = self.board[x][y].tile_type})
					end
				else
					if self.board[x][y].corrupted then
						local type = unhash[self.board[x][y].tile_type]
						if type == "rock" then
							self.board[x][y].corrupted = nil;
							msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("broken_rock")})
						else
							self.board[x][y].corrupted = false;
							msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = self.board[x][y].tile_type})
						end
					end
				end
			end
		end
	end
end

function corrupt_tile(self, x, y, completely)
	local type = unhash[self.board[x][y].tile_type]
	if type == "rock" then
		if self.board[x][y].corrupted == false and not completely then
			self.board[x][y].corrupted = nil
			msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("broken_rock")})
		else
			type = "broken_rock"
			self.board[x][y].corrupted = true;
			msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("bugged_" .. type)})
		end
	else
		self.board[x][y].corrupted = true;
		msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("bugged_" .. type)})
	end
end

function corruption_iteration(self)
	if turn_counter > corruption_beginning and corruption_delay == 0 then
		for i = 0, math.max(0, math.floor((turn_counter-(delay_cost-initial_delay_cost)/ability_cost_increase-corruption_beginning)/corruption_acceleration)) do
			local max_corrupted_around = 0
			local max_cor_ar_pos = first_corruption_hex_pos
			local candidates = {}
			for x = 0, boardwidth-1 do
				for y = 0, boardheight-1 do
					if check_coord(x, y) and self.board[x][y].id and not self.board[x][y].corrupted and 
					self.board[x][y].tile_type ~= hash("water") then
						local around_corrupted_count = 0
						if check_coord(x+1, y) and self.board[x+1][y].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end
						if check_coord(x-1, y) and self.board[x-1][y].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end
						if check_coord(x, y+1) and self.board[x][y+1].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end
						if check_coord(x, y-1) and self.board[x][y-1].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end
						local sdvig = -1 + (y%2)*2
						if check_coord(x+sdvig, y+1) and self.board[x+sdvig][y+1].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end
						if check_coord(x+sdvig, y-1) and self.board[x+sdvig][y-1].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end
						if around_corrupted_count == max_corrupted_around then
							table.insert(candidates, vmath.vector3(x,y,0))
						elseif around_corrupted_count > max_corrupted_around then
							max_corrupted_around = around_corrupted_count
							candidates = {}
							table.insert(candidates, vmath.vector3(x,y,0))
						end
					end
				end
			end
			if (#candidates ~= 0) then
				local coords_to_corrupt = candidates[math.random(#candidates)]
				corrupt_tile(self, coords_to_corrupt.x, coords_to_corrupt.y, false)
				label.set_text(msg.url(nil, self.board[coords_to_corrupt.x][coords_to_corrupt.y].id, "production_label"), 0)
			else
				msg.post("/end_screen#game_end", "game_lost")
			end
		end
	elseif turn_counter == corruption_beginning then
		corrupt_tile(self, first_corruption_hex_pos.x, first_corruption_hex_pos.y, true)
		label.set_text(msg.url(nil, self.board[first_corruption_hex_pos.x][first_corruption_hex_pos.y].id, "production_label"), 0)
	else
		corruption_delay = math.max(0, corruption_delay - 1)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("ability") then
		if not snow and message["ability"] == hash("snow") then
			delay_corrupt(self)
		elseif not thunder and message["ability"] == hash("thunder") and coins >= uncorrupt_cost then
			thunder_active = true
			msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder_active")})
		end
	elseif message_id == hash("next_turn") then
		turn_counter = turn_counter + 1
		corruption_iteration(self)
		score_calculation(self, hash("none"), hash("none"))
		if snow then
			snow = false
			for x = 0,boardwidth-1 do
				for y = 0,boardheight-1 do
					if self.board[x][y].corrupted then
						local type = unhash[self.board[x][y].tile_type]
						if type == "rock" then
							type = "broken_rock"
						end
						msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("bugged_" .. type)})
					end
				end
			end
		end
		thunder = false
		thunder_active = false
		if coins >= delay_cost then
			msg.post("/gui#main", "set_asset", {node_id = hash("snow"), anim_id = hash("snowflake")})
		else
			msg.post("/gui#main", "set_asset", {node_id = hash("snow"), anim_id = hash("snowflake_used")})
		end
		if coins >= uncorrupt_cost then
			msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder")})
		else
			msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder_used")})
		end
		if turn_counter == 68 then
			msg.post("/end_screen#game_end", "game_won")
		end
	elseif message_id == hash("new_tile") then
		message.position.z = 1
		moving_tile_id = factory.create("#hex_factory", message["position"], null, {tile_type = message["type"]})
		moving_tile_offset = message["offset"]
	elseif message_id == hash("update_tile") then
		self.board[message.x][message.y].tile_type = message.new_type
	elseif message_id == hash("reset_game") then
		for x = 0,boardwidth-1 do
			if self.board[x] then
				for y = 0,boardheight-1 do
					if self.board[x][y] then
						if self.board[x][y].id then
							go.delete(self.board[x][y].id)
						end
					end
				end
			end
		end
		delay_cost = initial_delay_cost
		uncorrupt_cost = initial_uncorrupt_cost
		msg.post("/gui#main", "gui_set_thunder_cost", {cost = uncorrupt_cost})
		msg.post("/gui#main", "gui_set_snow_cost", {cost = delay_cost})
		msg.post("/gui#main", "set_asset", {node_id = hash("snow"), anim_id = hash("snowflake_used")})
		msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder_used")})
		coins = 0
		coin_income = 0
		corruption_delay = 0
		wood_score = 0
		water_score = 0
		rock_score = 0
		wood_income = 0
		water_income = 0
		rock_income = 0
		bonus_limit = 6
		income = 0
		bonus = 0
		turn_counter = 0
		self.board = new_board()
		score_calculation(self, hash("none"), hash("none"))
	elseif message_id == "clear_corruption" then
		clear_corruption(self, true)
	end
end

function pick_hex(hex_x, hex_y, x, y)
	local a = 64
	local b = 70
	local t = a * b / (2 * a - b)
	return math.abs(hex_x - x) < a and math.abs(hex_y - y) < a and math.abs(hex_x - x) * a + math.abs(hex_y - y) * (t + a) < a * (t + a)
end

function return_hex_index_from_coords(self, x, y)
	local tmp_y = y - extraheight
	local tmp_x = x - extrawidth
	tmp_y = math.floor(tmp_y/(hex_size*3/4))
	tmp_x = math.floor(tmp_x/(hex_size))
	for i = (tmp_x - 1), tmp_x do
		for j = (tmp_y - 1), tmp_y do
			if i >= 0 and j >= 0 and i <= boardwidth-1 and j <= boardheight-1 then
				if (pick_hex(self.board[i][j].tile_pos_x, self.board[i][j].tile_pos_y, x, y)) then
					return i, j
				end
			end
		end
	end
	return -1, -1
end

local score = 0

function return_coords_from_hex_index(self, x, y)
	local pos = vmath.vector3(0, 0, 0)
	pos.x = 64+hex_size*x +extrawidth
	pos.y = 64+3*hex_size*y/4 +extraheight
	if y%2==1 then
		pos.x = pos.x + hex_size/2
	end
	pos.z = 1 / (y + 3)
	return pos
end

function close_hex_number(self, x, y)
	local close_hex = 0
	if check_coord(x+1, y) and self.board[x+1][y].id then
		close_hex = close_hex + 1
	end
	if check_coord(x-1, y) and self.board[x-1][y].id then
		close_hex = close_hex + 1
	end
	if check_coord(x, y+1) and self.board[x][y+1].id then
		close_hex = close_hex + 1
	end
	if check_coord(x, y-1) and self.board[x][y-1].id then
		close_hex = close_hex + 1
	end
	local sdvig = -1 + (y%2)*2
	if check_coord(x+sdvig, y+1) and self.board[x+sdvig][y+1].id then
		close_hex = close_hex + 1
	end
	if check_coord(x+sdvig, y-1) and self.board[x+sdvig][y-1].id then
		close_hex = close_hex + 1
	end
	return close_hex
end

function on_input(self, action_id, action)
	if action_id == hash("touch_left") and moving_tile_id then
		if action.released then
			local tile_x, tile_y = return_hex_index_from_coords(self, action.x, action.y)
			local moving_tile_url = msg.url(moving_tile_id)
			moving_tile_url.fragment = "tile"
			local tile_type = go.get(moving_tile_url, "tile_type")
			if check_coord(tile_x, tile_y) and not self.board[tile_x][tile_y].id and close_hex_number(self, tile_x, tile_y)>0 then
				local pos = return_coords_from_hex_index(self, tile_x, tile_y)
				go.animate(moving_tile_id, "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_LINEAR, 0.4)
				self.board[tile_x][tile_y] = {id = moving_tile_id, x = tile_x, y = tile_y, tile_pos_x = pos.x, tile_pos_y = pos.y, tile_type = tile_type, corrupted = false}
				msg.post("#", "next_turn")
				msg.post("/gui#main", "gui_new_tile")
			else
				go.delete(moving_tile_id)
				msg.post("/gui#main", "gui_revert_tile", {tile_type=tile_type})
			end
			moving_tile_id = nil
		else
			local pos = vmath.vector3(action.x, action.y, 0.5)
			go.set_position(pos - moving_tile_offset, moving_tile_id)
		end
		return true
	end
		
	if thunder_active and action_id == hash("touch_left") and action.pressed then
		thunder_active = false
		local tile_x, tile_y = return_hex_index_from_coords(self, action.x, action.y)
		if check_coord(tile_x, tile_y) and self.board[tile_x][tile_y].id and self.board[tile_x][tile_y].corrupted then
			heal_cell(self, tile_x, tile_y)
			thunder = true
			msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder_used")})
		else
			msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder")})
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
