local camera = require "orthographic.camera"

local hex_size
go.property("hex_size", 128)
local boardwidth
go.property("boardwidth", 18) -- always even
local boardheight
go.property("boardheight", 17) -- always 1 mod 4
local extrawidth
go.property("extrawidth", 0)
local extraheight
go.property("extraheight", 0)
local initial_delay_cost = 35
local initial_uncorrupt_cost = 35
local delay_cost = 35
local uncorrupt_cost = 35
BUY_TILE_COST = 40
local ability_cost_increase = 3
coins = 0
local coin_income = 0
local corruption_delay = 0
local start_hex_pos =  nil
local pointed_to_tile_x = 0
local pointed_to_tile_y = 0
local first_corruption_hex_pos = nil
local wood_score = 0
local water_score = 0
local rock_score = 0
local wood_income = 0
local water_income = 0
local rock_income = 0
local bonus_limit = 6
local income = 0
local bonus = 0
local turn_counter = 0
local moving_tile_id = nil
local moving_tile_offset = nil
local map_type = hash("hex")
go.property("map_type", hash("hex"))
local corruption_beginning = 16
local spawn_village_every_x_turn = 15
local corruption_acceleration = 10
local unhash = {
	[hash("wood")] = "wood",
	[hash("rock")] = "rock",
	[hash("broken_rock")] = "broken_rock",
	[hash("water")] = "water"
}
local thunder = false
thunder_active = false
local snow = false
local stats_visibility = false
local possible_moves_shown = false
local village_count = 0
local village_next_id = 1
local big_constant = 420
local max_turn = 232
local village_should_be_created = true
local just_created_village = false

local camera_x_bound = 320
local camera_y_bound = 180

local volume = 1

local neig_even_x = {-1, -1,  0, 1, 0, -1}
local neig_even_y = { 0, -1, -1, 0, 1,  1}
local neig_odd_x = {-1,  0,  1, 1, 1, 0}
local neig_odd_y = { 0, -1, -1, 0, 1, 1}

local neighbour_sdvig_x = {{-1, -1, 0,  1, 0, -1}, {-1, 0, 1,  1, 1, 0}} -- use like neighbour_sdvig_x[y%2+1][i]  i = 1 .. 6
local neighbour_sdvig_y = {{0,  -1, -1, 0, 1, 1}, {0,  -1, -1, 0, 1, 1}} -- use like neighbour_sdvig_y[y%2+1][i]

local theme_sound_gain = 0.02

local triangle_score = 0
local village_score = 0
local heal_cell_score = 0
local village2_score = 0
local village3_score = 0

local abilities_list = {hash("delay"), hash("uncorrupt")}
thunder_level = 1
thunder_max_level = 4
local stored_delay = 0
local stored_uncorrupt = 0
thunder_upgrade_cost = 200

SNOW_ANIM_TIME = 2
TILE_SHOW_HIDE_TIME = 1

function init(self)
	msg.post(".", "acquire_input_focus")
	defos.disable_window_resize()
	defos.on_mouse_enter(function ()
		defos.set_cursor_visible(false)
	end)
	defos.on_mouse_leave(function ()
		defos.set_cursor_visible(true)
	end)
	defos.set_cursor_visible(not defos.is_mouse_in_view())
	-- -- in case here are some settings that affect properties
	init_locals_from_properties("#")

	start_hex_pos = vmath.vector3(boardwidth / 2 - 1, (boardheight - 1) / 2,0)
	first_corruption_hex_pos = start_hex_pos
	pointed_to_tile_x = start_hex_pos.x
	pointed_to_tile_y = start_hex_pos.y
	
	self.board = new_board()
	make_possible_moves_around(self, start_hex_pos.x, start_hex_pos.y)
	make_possible_moves_around(self, start_hex_pos.x + 1, start_hex_pos.y)
	create_grid(self)
	self.villages = {}
	
	score_calculation(self, hash("none"), hash("none"))
	msg.post("/gui#main", "acquire_input_focus")
	msg.post("/tutorial#tutorial", "acquire_input_focus")
	msg.post("/cursor#cursor", "acquire_input_focus")
	msg.post("/gui#main", "gui_set_thunder_cost", {cost = stored_uncorrupt})
	msg.post("/gui#main", "gui_set_snow_cost", {cost = stored_delay})
	msg.post("/gui#main", "gui_set_thunder_upgrade_cost", {cost = thunder_upgrade_cost})
	sound.play("/sound#begining_of_game", { delay = 1, gain = theme_sound_gain * volume, pan = -1.0, speed = 1.0} )
end

function create_grid(self)
	self.grid = {}
	local pos = vmath.vector3()
	for x = 0,boardwidth-1 do
		pos.x = 64+hex_size*x +extrawidth
		self.grid[x] = {}
		for y = 0,boardheight-1 do
			if check_coord(x, y) then
				pos.y = 64+3*hex_size*y/4+extraheight
				if y%2==1 then
					pos.x = pos.x + hex_size/2
				end
				pos.z = 1 / (y + 3)
				pos.z = pos.z / 2
				local grid_id = factory.create("/game#boundaries_factory", pos, null)
				self.grid[x][y] = {id = grid_id}
				if y%2==1 then
					pos.x = pos.x - hex_size/2
				end
			end
		end
	end
end

function init_locals_from_properties(from_where)
	hex_size = go.get(from_where, "hex_size")
	boardwidth = go.get(from_where, "boardwidth")
	boardheight = go.get(from_where, "boardheight")
	extrawidth = go.get(from_where, "extrawidth")
	extraheight = go.get(from_where, "extraheight")
	map_type = go.get(from_where, "map_type")
end

function check_coord(x, y)
	if math.floor((boardheight + 1) / 4) <= x and x <= boardwidth - math.floor((boardheight + 1) / 4) - 1 and 0 <= y and y <= boardheight - 1 then
		return true
	elseif x < math.floor((boardheight + 1) / 4) and math.abs(y - math.floor(boardheight / 2)) <= 1 + 2 * x then
		return true
	elseif x > boardwidth - 1 - math.floor((boardheight + 1) / 4) and math.abs(y - math.floor(boardheight / 2)) <= 2 * (boardwidth - 1 - x) then
		return true
	else
		return false
	end
end

-- function check_coord(x, y)
-- 	if map_type == hash("hex") then
-- 		-- looks a bit like hex(octagon actually, but we need more height), requires some rework, but you get the idea
-- 		if (x >= boardwidth or x < 0 or y < 0 or y >= boardheight or
-- 		x + y < 3 or math.abs(boardwidth - 1 - x) + y < 3 or
-- 		x + math.abs(boardheight - 1 - y) < 3 or math.abs(boardwidth - 1 - x) + math.abs(boardheight - 1 - y) < 3 or 
-- 		(y%2 == 0 and x == 0) or (y%2 == 1 and x == 9)) and
-- 		not (x == 0 and y == 4) and 
-- 		not (x == 1 and y == 1) and 
-- 		not (x == 2 and y == 0) and 
-- 		not (x == 1 and y == 7) and 
-- 		not (x == 2 and y == 8) and 
-- 		not (x == 7 and y == 8) and 
-- 		not (x == 7 and y == 0)
-- 		then
-- 			return false
-- 		end
-- 		return true
-- 	else
-- 		if (x >= boardwidth or x < 0 or y < 0 or y >= boardheight) then
-- 			return false
-- 		end
-- 		return true
-- 	end
-- end

function is_hex_valid_dfs(self, used, x, y, type)
	return check_coord(x, y) and self.board[x][y].id and used[x][y] == 0 and self.board[x][y].tile_type == type and not self.board[x][y].corrupted
end

function spawn_resource(self, x, y)
	if self.board[x][y].id and not self.board[x][y].corrupted then
		local pos = vmath.vector3(self.board[x][y].tile_pos_x, self.board[x][y].tile_pos_y, 1)
		pos.z = pos.z - 0.1
		timer.delay(0.5, false, function ()
			factory.create("#coin_factory", pos, null, {type = self.board[x][y].tile_type})
		end)
	end
end

-- function set_tile_group (self, x, y, type)
-- 	if type == hash("wood") then
-- 		local pos = vmath.vector3()
-- 		pos.x = self.board[x][y].tile_pos_x
-- 		pos.y = self.board[x][y].tile_pos_y
-- 		pos.z = 1 / (pos.y + 3)
-- 		if self.board[x][y] and self.board[x][y].id and self.board[x][y].id_group then
-- 			msg.post(msg.url(nil, self.board[x][y].id_group, "sprite"), "play_animation", {id = hash("group_wood")})
-- 		else
-- 			self.board[x][y].id_group = factory.create("/game#group_factory", pos, null, {group_type = hash("group_wood")})
-- 		end
-- 	elseif type == hash("rock") then
-- 		local pos = vmath.vector3()
-- 		pos.x = self.board[x][y].tile_pos_x
-- 		pos.y = self.board[x][y].tile_pos_y
-- 		pos.z = 1 / (pos.y + 3)
-- 		if self.board[x][y] and self.board[x][y].id and self.board[x][y].id_group then
-- 			msg.post(msg.url(nil, self.board[x][y].id_group, "sprite"), "play_animation", {id = hash("group_rock")})
-- 		else 
-- 			self.board[x][y].id_group = factory.create("/game#group_factory", pos, null, {group_type = hash("group_rock")})
-- 		end
-- 	elseif type == hash("water") then
-- 		local pos = vmath.vector3()
-- 		pos.x = self.board[x][y].tile_pos_x
-- 		pos.y = self.board[x][y].tile_pos_y
-- 		pos.z = 1 / (pos.y + 3)
-- 		if self.board[x][y] and self.board[x][y].id and self.board[x][y].id_group then
-- 			msg.post(msg.url(nil, self.board[x][y].id_group, "sprite"), "play_animation", {id = hash("group_water")})
-- 		else 
-- 			self.board[x][y].id_group = factory.create("/game#group_factory", pos, null, {group_type = hash("group_water")})
-- 		end
-- 	end
-- end - подсвекта (пока не нужно возможно надо удалить)

--[[function is_hex_valid_bridges(self, x, y, type)
	return check_coord(x, y) and self.board[x][y].id and self.board[x][y].tile_type == type and not self.board[x][y].corrupted
end

function find_bridge(self, used, tin, fup, x, y, type, time, prev_x, prev_y)
	used[x][y] = 1
	tin[x][y] = time
	fup[x][y] = time
	time = time + 1
	if check_coord(x, y) and not self.board[x][y].corrupted then
		for i = 1, 6 do
			if is_hex_valid_dfs(self, used, x + neighbour_sdvig_x[y%2+1][i], y + neighbour_sdvig_y[y%2+1][i], type) then 
				dfs(self, used, x + neighbour_sdvig_x[y%2+1][i], y + neighbour_sdvig_y[y%2+1][i], type)
			end
		end
	end

end
--]]

function dfs(self, used, x, y, type) 
	used[x][y] = 1
	if income > 0 and bonus < bonus_limit then 
		bonus = bonus + 1
	end
	if self.board[x][y].structure_name ~= nil then 
		income = income + 2
	else 
		income = income + 1
	end
	if check_coord(x, y) and not self.board[x][y].corrupted then
		for i = 1, 6 do
			if is_hex_valid_dfs(self, used, x + neighbour_sdvig_x[y%2+1][i], y + neighbour_sdvig_y[y%2+1][i], type) then 
				dfs(self, used, x + neighbour_sdvig_x[y%2+1][i], y + neighbour_sdvig_y[y%2+1][i], type)
			end
		end
	end
end

function tile_group(self, type)
	local used = {}
	for i = 0,boardwidth-1 do
		used[i] = {}
		for j = 0,boardheight-1 do
			used[i][j] = 0
		end
	end
	bonus = 0
	income = 0
	reset_income(type)
	for i = 0, boardwidth - 1 do 
		for j = 0, boardheight - 1 do
			if is_hex_valid_dfs(self, used, i, j, type)then
				dfs(self, used, i, j, type)
				update_income(type)
				bonus = 0
				income = 0
			end
		end
	end
end

function score_calculation(self, new_type, old_type)
	--[[
	tile_group(self, hash("wood"))
	wood_score = wood_score + wood_income
	coin_income = wood_income
	tile_group(self, hash("water"))
	water_score = water_score + water_income
	coin_income = coin_income + water_income
	tile_group(self, hash("rock"))
	rock_score = rock_score + rock_income
	coin_income = coin_income + rock_income
	coins = coins + coin_income
	msg.post("/gui#main", "gui_set_coins", {coins = coins})
	msg.post("/gui#main", "gui_set_income", {income = coin_income})
	--]]
	coin_income = 0
	for village_num = 1, #self.villages do
		if self.villages[village_num].id then
			coin_income = coin_income + self.villages[village_num].income
		end
	end
	coins = coins + coin_income
	msg.post("/gui#main", "gui_set_coins", {coins = coins})
	msg.post("/gui#main", "gui_set_income", {income = coin_income})
end

function reset_income (type)
	if type == hash("wood") then
		wood_income = 0
	elseif type == hash("water") then
		water_income = 0
	elseif type == hash("rock") then
		rock_income = 0
	end
end

function update_income (type)
	if type == hash("wood") then
		wood_income = wood_income + 3 * income + bonus
	elseif type == hash("water") then
		water_income = water_income + income + 3 * bonus
	elseif type == hash("rock") then
		rock_income = rock_income + 2 * income + 2 * bonus
	end
end

function heal_cell(self, x, y)
	if self.board[x][y].corrupted then
		self.board[x][y].corrupted = false;
		msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = self.board[x][y].tile_type})
		heal_cell_score = heal_cell_score + 1
		if village_count >= 0 then
			if self.board[x][y].distance_to_village ~= big_constant then
				msg.post(msg.url(nil, self.villages[self.board[x][y].village_num].id, "village"), "get_resource", 
				{tile_type = self.board[x][y].tile_type, radius = self.board[x][y].distance_to_village, x = x , y = y, volume = volume})
			end
		end
	end
end

function delay_corrupt(self, middle_pos)
	local middle_hex_x, middle_hex_y
	middle_hex_x, middle_hex_y = return_hex_index_from_coords(self, middle_pos.x, middle_pos.y)
	if stored_delay >= 1 then
		snow = true
		corruption_delay = 1
		stored_delay = stored_delay - 1
		msg.post("/gui#main", "gui_set_snow_cost", {cost = stored_delay})
		msg.post("/gui#main", "set_asset", {node_id = hash("snow"), anim_id = hash("snowflake_active")})
		for x = 0,boardwidth-1 do
			for y = 0,boardheight-1 do
				if self.board[x][y].corrupted then
					local type = unhash[self.board[x][y].tile_type]
					if type == "rock" then
						type = "broken_rock"
					end
					
					local distance = math.floor((abs(middle_hex_x - x)^2 + abs(middle_hex_y - y)^2)^(1/2))
					timer.delay(SNOW_ANIM_TIME * distance/((math.floor((boardwidth)^2 + (boardheight)^2)^(1/2))+1), false, function ()
						msg.post(msg.url(nil, self.grid[x][y].id, "boundaries"), "make_blue")
						local low_pos = go.get_position(self.grid[x][y].id)
						local high_pos = vmath.vector3(low_pos.x, low_pos.y, 0.9)
						go.set_position(high_pos, self.grid[x][y].id)
						msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("bugged_" .. type .. "-" .. math.random(1, 5))})
						timer.delay(0.3, false, function ()
							go.set_position(low_pos, self.grid[x][y].id)
							msg.post(msg.url(nil, self.grid[x][y].id, "boundaries"), "make_light")
						end)
					end)
				end
			end
		end
	end
end

function thunder_usage(self, tile_x, tile_y)
	local actually_healed = 0
	if check_coord(tile_x, tile_y) and self.board[tile_x][tile_y].id and self.board[tile_x][tile_y].corrupted then
		heal_cell(self, tile_x, tile_y)
		make_upgrade_structure(self, tile_x, tile_y)
		actually_healed = actually_healed + 1
	end
	if thunder_level >= 2 then
		if check_coord(tile_x + 1, tile_y) and self.board[tile_x + 1][tile_y].id and self.board[tile_x + 1][tile_y].corrupted then
			heal_cell(self, tile_x + 1, tile_y)
			make_upgrade_structure(self, tile_x + 1, tile_y)
			actually_healed = actually_healed + 1
		end
	end
	if thunder_level >= 3 then
		local sdvig = tile_y%2
		if check_coord(tile_x + sdvig, tile_y + 1) and self.board[tile_x + sdvig][tile_y + 1].id and self.board[tile_x + sdvig][tile_y + 1].corrupted then
			heal_cell(self, tile_x + sdvig, tile_y + 1)
			make_upgrade_structure(self, tile_x + sdvig, tile_y + 1)
			actually_healed = actually_healed + 1
		end
		if check_coord(tile_x + sdvig, tile_y - 1) and self.board[tile_x + sdvig][tile_y - 1].id and self.board[tile_x + sdvig][tile_y - 1].corrupted then
			heal_cell(self, tile_x + sdvig, tile_y - 1)
			make_upgrade_structure(self, tile_x + sdvig, tile_y - 1)
			actually_healed = actually_healed + 1
		end
	end
	if thunder_level >= 4 then
		local tmp_x, tmp_y
		for i = 1, 6 do
			tmp_x = tile_x + neighbour_sdvig_x[tile_y%2+1][i]
			tmp_y = tile_y + neighbour_sdvig_y[tile_y%2+1][i]
			if check_coord(tmp_x, tmp_y) and self.board[tmp_x][tmp_y].id and self.board[tmp_x][tmp_y].corrupted then
				heal_cell(self, tmp_x, tmp_y)
				make_upgrade_structure(self, tmp_x, tmp_y)
				actually_healed = actually_healed + 1
			end
		end
	end
	
	msg.post("/thunder_area", "hide")
	if actually_healed > 0 then
		thunder = true
		stored_uncorrupt = stored_uncorrupt - 1
		msg.post("/gui#main", "gui_set_thunder_cost", {cost = stored_uncorrupt})
		msg.post("/gui#main", "gui_set_coins", {coins = coins})
		return true
	else
		return false
	end
end

function new_board()
	math.randomseed(os.clock())
	local new_board = {}
	local pos = vmath.vector3()
	local x = 0
	local y = 0
	local starting_set = {hash("rock"), hash("wood")}
	for x = 0,boardwidth-1 do
		pos.x = 64+hex_size*x +extrawidth
		new_board[x] = {}
		for y = 0,boardheight-1 do
			pos.y = 64+3*hex_size*y/4 +extraheight
			if y%2==1 then
				pos.x = pos.x + hex_size/2
			end
			local tile_type = nil
			local id_tile
			--[[  for check_coord tests
			if check_coord(x, y) then
				id_tile = factory.create("#hex_factory", pos, null, {tile_type = tile_type})
			end 
			--]]
			if (x == start_hex_pos.x or x == start_hex_pos.x +1) and y == start_hex_pos.y then
				random_pick = math.random(#starting_set)
				tile_type = starting_set[random_pick]
				if tile_type == hash("wood") then
					first_corruption_hex_pos = vmath.vector3(x,y,0)
				end
				table.remove(starting_set, random_pick)
				pos.z = 1 / (y + 3)
				id_tile = factory.create("#hex_factory", pos, null, {tile_type = tile_type})
			else
				id_tile = nil
			end
			new_board[x][y] = {id = id_tile, x = x, y = y, tile_pos_x = pos.x, tile_pos_y = pos.y, tile_type = tile_type, corrupted = false, possible_move = false,
			distance_to_village = big_constant, village_center_x = nil, village_center_y = nil, village_num = nil, structure_direction = nil, structure_name = nil}
			if y%2==1 then
				pos.x = pos.x - hex_size/2
			end
		end
	end
	return new_board
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function clear_corruption(self, completely)
	for x = 0,boardwidth-1 do
		for y = 0,boardheight-1 do
			if self.board[x][y].id then
				if completely then
					if self.board[x][y].corrupted then
						self.board[x][y].corrupted = false;
						msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = self.board[x][y].tile_type})
					end
				else
					if self.board[x][y].corrupted then
						local type = unhash[self.board[x][y].tile_type]
						if type == "rock" then
							self.board[x][y].corrupted = nil;
							msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("broken_rock")})
						else
							self.board[x][y].corrupted = false;
							msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = self.board[x][y].tile_type})
						end
					end
				end
			end
		end
	end
end

function corrupt_tile(self, x, y, completely)
	if not self.board[x][y].corrupted then
		local type = unhash[self.board[x][y].tile_type]
		if type == "rock" then
			if self.board[x][y].corrupted == false and not completely then
				self.board[x][y].corrupted = nil
				msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("broken_rock")})
			else
				type = "broken_rock"
				self.board[x][y].corrupted = true;
				msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("bugged_" .. type)})
			end
		else
			self.board[x][y].corrupted = true;
			msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("bugged_" .. type)})
		end
		if village_count >= 0 and self.board[x][y].corrupted then
			subtract_resource_from_villages(self, self.board[x][y].tile_type, x, y)
		end
	end
end

function global_bfs(self, x, y, village_num)
	local visited = {}
	local next = {}
	next[0] = {}
	next[1] = {}
	for i = 0, boardwidth-1 do
		visited[i] = {}
		for j = 0, boardheight-1 do
			visited[i][j] = 0
		end
	end
	local depth = 0
	table.insert(next[depth%2], {next_x = x, next_y = y})
	while #next[0] ~= 0 or #next[1] ~= 0 do
		for next_hex_num = 1, #next[depth%2] do
			bfs_handle_hex(self, next_hex_num, next, depth, x, y, visited, village_num)
		end
		next[depth%2] = {}
		depth = depth + 1
	end
end

function bfs_handle_hex(self, hex_number, next, depth, village_x, village_y, visited, village_num)
	local x = next[depth%2][hex_number].next_x
	local y = next[depth%2][hex_number].next_y
	visited[x][y] = 1
	if check_coord(x, y) and depth <= self.board[x][y].distance_to_village then
		if depth < self.board[x][y].distance_to_village then
			if self.board[x][y].village_num ~= nil and self.board[x][y].id and self.board[x][y].village_num ~= village_num then
				if self.board[x][y].structure_name ~= nil then
					subtract_resource_from_villages(self, self.board[x][y].tile_type, x, y)
				end
				subtract_resource_from_villages(self, self.board[x][y].tile_type, x, y)
			end
			self.board[x][y].distance_to_village = depth
			self.board[x][y].village_center_x = village_x
			self.board[x][y].village_center_y = village_y
			self.board[x][y].village_num = village_num
		end

		local tmp_x, tmp_y
		for i = 1, 6 do
			tmp_x = x + neighbour_sdvig_x[y%2+1][i]
			tmp_y = y + neighbour_sdvig_y[y%2+1][i]
			if check_coord(tmp_x, tmp_y) and visited[tmp_x][tmp_y] == 0 then
				visited[tmp_x][tmp_y] = 1
				table.insert(next[(depth+1)%2], {next_x = tmp_x, next_y = tmp_y})
			end
		end
		--[[
		local sdvig = -1 + (y%2)*2
		if check_coord(x+1, y) and visited[x+1][y] == 0 then
			visited[x+1][y] = 1
			table.insert(next[(depth+1)%2], {next_x = x+1, next_y = y})
		end
		if check_coord(x-1, y) and visited[x-1][y] == 0 then
			visited[x-1][y] = 1
			table.insert(next[(depth+1)%2], {next_x = x-1, next_y = y})
		end
		if check_coord(x, y+1) and visited[x][y+1] == 0 then
			visited[x][y+1] = 1
			table.insert(next[(depth+1)%2], {next_x = x, next_y = y+1})
		end
		if check_coord(x, y-1) and visited[x][y-1] == 0 then
			visited[x][y-1] = 1
			table.insert(next[(depth+1)%2], {next_x = x, next_y = y-1})
		end
		if check_coord(x+sdvig, y+1) and visited[x+sdvig][y+1] == 0 then
			visited[x+sdvig][y+1] = 1
			table.insert(next[(depth+1)%2], {next_x = x+sdvig, next_y = y+1})
		end
		if check_coord(x+sdvig, y-1) and visited[x+sdvig][y-1] == 0 then
			visited[x+sdvig][y-1] = 1
			table.insert(next[(depth+1)%2], {next_x = x+sdvig, next_y = y-1})
		end 
		]]
	end
end

function grow_bfs(self, village_num, x ,y)
	self.villages[village_num].radius = 2
	local visited = {}
	local next = {}
	next[0] = {}
	next[1] = {}
	for i = x-3, x+3 do
		visited[i] = {}
		for j = y-3, y+3 do
			visited[i][j] = 0
		end
	end
	local depth = 0
	table.insert(next[depth%2], {next_x = x, next_y = y})
	while depth <= 2 do
		for next_hex_num = 1, #next[depth%2] do
			grow_bfs_handle_hex(self, next_hex_num, next, depth, x, y, visited, village_num)
		end
		next[depth%2] = {}
		depth = depth + 1
	end
end

function grow_bfs_handle_hex(self, hex_number, next, depth, village_x, village_y, visited, village_num)
	local x = next[depth%2][hex_number].next_x
	local y = next[depth%2][hex_number].next_y
	visited[x][y] = 1
	if check_coord(x, y) and depth <= self.board[x][y].distance_to_village then
		if depth < self.board[x][y].distance_to_village or 
		(depth == self.board[x][y].distance_to_village) and depth == 2 and
		self.villages[self.board[x][y].village_num].radius == 1 and
		self.board[x][y].village_num ~= village_num then
		self.board[x][y].distance_to_village = depth
		self.board[x][y].village_center_x = village_x
		self.board[x][y].village_center_y = village_y
		self.board[x][y].village_num = village_num
		if self.board[x][y].id and depth == 2 then 
			if self.board[x][y].structure_name ~= nil then
				timer.delay(0.5, false, function ()
					add_resource_to_villages(self, self.board[x][y].tile_type, x, y)
				end)
			end
			add_resource_to_villages(self, self.board[x][y].tile_type, x, y)
		end
		elseif village_num == self.board[x][y].village_num and self.board[x][y].id and depth == 2 then
			if self.board[x][y].structure_name ~= nil then
				timer.delay(0.5, false, function ()
					add_resource_to_villages(self, self.board[x][y].tile_type, x, y)
				end)
			end
			add_resource_to_villages(self, self.board[x][y].tile_type, x, y)
		end

		local tmp_x, tmp_y
		for i = 1, 6 do
			tmp_x = x + neighbour_sdvig_x[y%2+1][i]
			tmp_y = y + neighbour_sdvig_y[y%2+1][i]
			if check_coord(tmp_x, tmp_y) and visited[tmp_x][tmp_y] == 0 then
				visited[tmp_x][tmp_y] = 1
				table.insert(next[(depth+1)%2], {next_x = tmp_x, next_y = tmp_y})
			end
		end
		--[[
		local sdvig = -1 + (y%2)*2
		if check_coord(x+1, y) and visited[x+1][y] == 0 then
			visited[x+1][y] = 1
			table.insert(next[(depth+1)%2], {next_x = x+1, next_y = y})
		end
		if check_coord(x-1, y) and visited[x-1][y] == 0 then
			visited[x-1][y] = 1
			table.insert(next[(depth+1)%2], {next_x = x-1, next_y = y})
		end
		if check_coord(x, y+1) and visited[x][y+1] == 0 then
			visited[x][y+1] = 1
			table.insert(next[(depth+1)%2], {next_x = x, next_y = y+1})
		end
		if check_coord(x, y-1) and visited[x][y-1] == 0 then
			visited[x][y-1] = 1
			table.insert(next[(depth+1)%2], {next_x = x, next_y = y-1})
		end
		if check_coord(x+sdvig, y+1) and visited[x+sdvig][y+1] == 0 then
			visited[x+sdvig][y+1] = 1
			table.insert(next[(depth+1)%2], {next_x = x+sdvig, next_y = y+1})
		end
		if check_coord(x+sdvig, y-1) and visited[x+sdvig][y-1] == 0 then
			visited[x+sdvig][y-1] = 1
			table.insert(next[(depth+1)%2], {next_x = x+sdvig, next_y = y-1})
		end  
		]]
	end
end

function abs(a)
	if a < 0 then
		return -a
	else
		return a
	end
end

function bool_hex2_arond_hex1_in_radius2(x1, y1, x2, y2)
	if (abs(y1 - y2) < 3) and  (abs(x1 - x2) < 3) and (abs(x1 - x2) + abs(y1 - y2) < 4) and
	not (x1 - x2 == (-1 + (y1%2)*2)*2 and abs(x1 - x2) == 2 and abs(y1 - y2) == 1)
	then
		return true
	else
		return false
	end
end

function village_creation(self, x, y)
	for village_num = 1, village_count do
		if self.villages[village_num].id then
			if bool_hex2_arond_hex1_in_radius2(self.villages[village_num].x, self.villages[village_num].y, x, y) then
				return false
			end
		end
	end
	if self.board[x][y].structure_name ~= nil then
		destroy_structure(self, x, y)
	end
	local pos = return_coords_from_hex_index(self, x, y)
	msg.post(msg.url(nil, self.board[x][y].id, "tile"), "hide_slowly")
	id_village = factory.create("#village_factory", pos, null, {id = village_next_id, x = x, y = y})
	self.villages[village_next_id] = {id = id_village, x = x, y = y, radius = 1, village_order = village_next_id, income = 0, level = 1}
	self.board[x][y].village_center_x = x
	self.board[x][y].village_center_y = y
	self.board[x][y].distance_to_village = 0
	self.board[x][y].village_num = village_next_id
	global_bfs(self, x, y, village_next_id)
	village_count = village_count + 1
	for i = x-1, x+1 do
		for j = y-1, y+1 do
			if check_coord(i, j) and self.board[i][j].id and self.board[i][j].village_num == village_next_id 
			and self.board[i][j].distance_to_village == 1 and not self.board[i][j].corrupted then
				if self.board[i][j].structure_name ~= nil then
					timer.delay(0.5, false, function ()
						add_resource_to_villages(self, self.board[i][j].tile_type, i, j)
					end)
				end
				add_resource_to_villages(self, self.board[i][j].tile_type, i, j)
			end
		end
	end
	village_next_id = village_next_id + 1
	
	village_should_be_created = false
	just_created_village = true	
	village_score = village_score + 1
	msg.post("/sound#sound_gate", "play_gated_sound", {soundcomponent = "/sound#village_creation",  gain = 0.02*volume, delay = 0.2, pan = -1.0, speed = 0.7})
	return true
end

function village_destruction(self, village_num, x, y)
	if village_num == 0 then
		village_num = self.board[x][y].village_num
	else
		x = self.villages[village_num].x
		y = self.villages[village_num].y
	end
	if self.villages[village_num].id then
		msg.post(msg.url(nil, self.board[x][y].id, "tile"), "show_slowly")
		for i = 0, boardwidth-1 do
			for j = 0, boardheight-1 do
				if check_coord(i, j) and self.board[i][j].village_num == village_num then
					self.board[i][j].distance_to_village = big_constant
					self.board[i][j].village_center_x = nil
					self.board[i][j].village_center_y = nil
					self.board[i][j].village_num = nil
				end
			end
		end
		msg.post(msg.url(nil, self.villages[village_num].id, "village"), "delete_slowly")
		self.villages[village_num].id = nil
		village_count = village_count - 1
		for other_village_num = 1, (#self.villages) do
			if self.villages[other_village_num].id then
				global_bfs(self, self.villages[other_village_num].x, self.villages[other_village_num].y, other_village_num)
			end
		end
	end

	msg.post("/sound#sound_gate", "play_gated_sound", {soundcomponent = "/sound#village_destruction",  gain = 0.02*volume, delay = 0.2, pan = -1.0, speed = 0.7})
end

function add_resource_to_villages(self, tile_type, x, y)
	if village_count >= 0 then
		if self.board[x][y].distance_to_village ~= big_constant then
			msg.post(msg.url(nil, self.villages[self.board[x][y].village_num].id, "village"), "get_resource", 
			{tile_type = tile_type, radius = self.board[x][y].distance_to_village, x = x , y = y, volume = volume})
		end
	end
end

function subtract_resource_from_villages(self, tile_type, x, y)
	if village_count >= 0 then
		if self.board[x][y].distance_to_village ~= big_constant then
			msg.post(msg.url(nil, self.villages[self.board[x][y].village_num].id, "village"), "lose_resource", 
			{tile_type = tile_type, radius = self.board[x][y].distance_to_village, x = x , y = y})
		end
	end
end

function spawn_ability(self)
	local candidates_close = {}
	local candidates_far = {}
	local min_distance = big_constant
	for x = 0, boardwidth-1 do
		for y = 0, boardheight-1 do
			if check_coord(x, y) and not self.board[x][y].id and not self.board[x][y].tile_type 
			and not self.board[x][y].possible_move then
				if self.board[x][y].distance_to_village == min_distance then
					table.insert(candidates_close, vmath.vector3(x,y,0))
				elseif self.board[x][y].distance_to_village == min_distance + 1 then
					table.insert(candidates_far, vmath.vector3(x,y,0))
				elseif self.board[x][y].distance_to_village == min_distance - 1 then
					min_distance = self.board[x][y].distance_to_village
					candidates_far = candidates_close
					candidates_close = {}
					table.insert(candidates_close, vmath.vector3(x,y,0))
				elseif self.board[x][y].distance_to_village < min_distance then
					min_distance = self.board[x][y].distance_to_village
					candidates_close = {}
					candidates_far = {}
					table.insert(candidates_close, vmath.vector3(x,y,0))
				end
			end
		end
	end
	local coords_to_spawn, coords_to_spawn_close, coords_to_spawn_far
	if (#candidates_close ~= 0) and (#candidates_far ~= 0) then
		coords_to_spawn_close = candidates_close[math.random(#candidates_close)]
		coords_to_spawn_far = candidates_far[math.random(#candidates_far)]
		if math.random(0, 1) == 0 then -- choose from close
			print("close", 1)
			coords_to_spawn = coords_to_spawn_close
		else -- choose from far
			print("far", 1)
			coords_to_spawn = coords_to_spawn_far
		end
	elseif (#candidates_close ~= 0) then 
		print("close", 2)
		coords_to_spawn = candidates_close[math.random(#candidates_close)]
	elseif (#candidates_far ~= 0) then
		print("far", 2)
		coords_to_spawn = candidates_far[math.random(#candidates_far)]
	else 
		return false
	end
	local x = coords_to_spawn.x
	local y = coords_to_spawn.y
	print(x,y)
	local new_ability_type = abilities_list[math.random(#abilities_list)]
	local pos = return_coords_from_hex_index(self, x, y)
	pos.z = 1
	pos.y = pos.y + 10
	id_sparkle = factory.create("#sparkle_factory", pos, null, {ability_type = new_ability_type})
	self.board[x][y].tile_type = id_sparkle
end

function placed_on_tile(self, tile_x, tile_y)
	if self.board[tile_x][tile_y].tile_type then
		msg.post(msg.url(nil, self.board[tile_x][tile_y].tile_type, "sparkle"), "activated")
	end 
end

function corruption_iteration(self)
	if turn_counter > corruption_beginning and corruption_delay == 0 then
		for i = 0, (math.max(0, math.floor((turn_counter-(delay_cost-initial_delay_cost)/ability_cost_increase-corruption_beginning)/corruption_acceleration))) - 1 + (turn_counter%2) do
			local max_corrupted_around = -10
			local max_cor_ar_pos = first_corruption_hex_pos
			local candidates = {}
			for x = 0, boardwidth-1 do
				for y = 0, boardheight-1 do
					if check_coord(x, y) and self.board[x][y].id and not self.board[x][y].corrupted and 
					self.board[x][y].tile_type ~= hash("water") then
						local around_corrupted_count = 0

						local tmp_x, tmp_y
						for i = 1, 6 do
							tmp_x = x + neighbour_sdvig_x[y%2+1][i]
							tmp_y = y + neighbour_sdvig_y[y%2+1][i]
							if check_coord(tmp_x, tmp_y) and self.board[tmp_x][tmp_y].corrupted then
								around_corrupted_count = around_corrupted_count + 1
							end
						end
						
						--[[
						if check_coord(x+1, y) and self.board[x+1][y].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end
						if check_coord(x-1, y) and self.board[x-1][y].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end
						if check_coord(x, y+1) and self.board[x][y+1].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end
						if check_coord(x, y-1) and self.board[x][y-1].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end
						local sdvig = -1 + (y%2)*2
						if check_coord(x+sdvig, y+1) and self.board[x+sdvig][y+1].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end
						if check_coord(x+sdvig, y-1) and self.board[x+sdvig][y-1].corrupted then
							around_corrupted_count = around_corrupted_count+1
						end 
						--]]
						
						if self.board[x][y].distance_to_village == 1 then
							around_corrupted_count = around_corrupted_count-1
						elseif self.board[x][y].distance_to_village == 0 then
							around_corrupted_count = around_corrupted_count-2
						end
						if around_corrupted_count == max_corrupted_around then
							table.insert(candidates, vmath.vector3(x,y,0))
						elseif around_corrupted_count > max_corrupted_around then
							max_corrupted_around = around_corrupted_count
							candidates = {}
							table.insert(candidates, vmath.vector3(x,y,0))
						end
					end
				end
			end
			if (#candidates ~= 0) then
				local coords_to_corrupt = candidates[math.random(#candidates)]
				if self.board[coords_to_corrupt.x][coords_to_corrupt.y].distance_to_village == 0 then
					local delay = 0
					if just_created_village then
						delay = TILE_SHOW_HIDE_TIME + 0.1
					end
					timer.delay(delay, false, function ()
						village_destruction(self, 0, coords_to_corrupt.x, coords_to_corrupt.y)
						corrupt_tile(self, coords_to_corrupt.x, coords_to_corrupt.y, true)
					end)
					return
				else
					if self.board[coords_to_corrupt.x][coords_to_corrupt.y].structure_name ~= nil then
						destroy_structure(self, coords_to_corrupt.x, coords_to_corrupt.y)
					end
					corrupt_tile(self, coords_to_corrupt.x, coords_to_corrupt.y, false)
					for i = 1, 6 do
						make_upgrade_structure(self, coords_to_corrupt.x + neighbour_sdvig_x[coords_to_corrupt.y%2+1][i], coords_to_corrupt.y + neighbour_sdvig_y[coords_to_corrupt.y%2+1][i])
					end
				end
			else
				sound.stop("/sound")
				msg.post("/end_screen#game_end", "game_lost", {triangle_score = triangle_score, village_score = village_score, 
				heal_cell_score = heal_cell_score, village2_score = village2_score, village3_score = village3_score, turn_counter = turn_counter,
			volume = volume})
			end
		end
	elseif turn_counter == corruption_beginning then
		local candidates = {}
		local board_max = -1
		for x, row in pairs(self.board) do
			for y, tile in pairs(row) do
				if tile.id and tile.tile_type ~= hash('water') then
					if tile.distance_to_village > board_max then
						board_max = tile.distance_to_village
						candidates = {}
						table.insert(candidates, {x, y})
					elseif tile.distance_to_village == board_max then
						table.insert(candidates, {x, y})
					end
				end
			end
		end
		corruption_start = candidates[math.random(1, #candidates)]
		first_corruption_hex_pos.x = corruption_start[1]
		first_corruption_hex_pos.y = corruption_start[2]
		if self.board[first_corruption_hex_pos.x][first_corruption_hex_pos.y].structure_name ~= nil then
			destroy_structure(self, first_corruption_hex_pos.x, first_corruption_hex_pos.y)
		end
		corrupt_tile(self, first_corruption_hex_pos.x, first_corruption_hex_pos.y, true)
		
		sound.stop("/sound#begining_of_game")
		sound.play("/sound#corruption_appears_theme", { delay = 1, gain = 0.08*volume, pan = -1.0, speed = 1.0} )
		for i = 1, 6 do
			make_upgrade_structure(self, first_corruption_hex_pos.x + neighbour_sdvig_x[first_corruption_hex_pos.y%2+1][i], first_corruption_hex_pos.y + neighbour_sdvig_y[first_corruption_hex_pos.y%2+1][i])
		end
	else
		corruption_delay = math.max(0, corruption_delay - 1)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("ability") then
		if not snow and message["ability"] == hash("snow") then
			local world_pos = camera.window_to_world(hash('/camera'), vmath.vector3(message["action_x"], message["action_y"], 0))
			delay_corrupt(self, world_pos)
			msg.post("/sound#sound_gate", "play_gated_sound", {soundcomponent = "/sound#snow",  gain = 0.02*volume, delay = 0.2, pan = -1.0, speed = 0.7})
		elseif message["ability"] == hash("thunder") then
			if not thunder then
				if stored_uncorrupt >= 1 then
					thunder_active = true
					msg.post("/thunder_area", "show")
					msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder_active")})
				else
					msg.post("/gui#main", "thunder_not_used", {action = "open", still_can_do = true})
					msg.post("/cursor#cursor", "thunder_not_used", {action = "open"})
				end
			else
				msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder_used")})
			end
		elseif message["ability"] == hash("buy_tile") then
			coins = coins - BUY_TILE_COST
		end
	elseif message_id == hash("next_turn") then
		add_resource_to_villages(self, message["tile_type"], message["x"], message["y"])
		if village_should_be_created == true then
			local candidates = {}
			local board_max = -1
			for x, row in pairs(self.board) do
				for y, tile in pairs(row) do
					if tile.id and tile.corrupted == false then
						if tile.distance_to_village > board_max then
							board_max = tile.distance_to_village
							candidates = {}
							table.insert(candidates, {x, y})
						elseif tile.distance_to_village == board_max then
							table.insert(candidates, {x, y})
						end
					end
				end
			end
			if #candidates > 0 then
				village_coords = candidates[math.random(1, #candidates)]
				if village_creation(self, village_coords[1], village_coords[2]) then
					msg.post("/gui#main", "next_village", {turns = spawn_village_every_x_turn - math.fmod(turn_counter, spawn_village_every_x_turn)})
				end
			end
		else
			msg.post("/gui#main", "next_village", {turns = spawn_village_every_x_turn - math.fmod(turn_counter, spawn_village_every_x_turn)})
		end
		if turn_counter > corruption_beginning and turn_counter % 1 == 0 then
			spawn_ability(self)
		end
		turn_counter = turn_counter + 1
		corruption_iteration(self)
		make_upgrade_structure(self, message["x"], message["y"])
		if turn_counter == corruption_beginning then
			msg.post("/tutorial#tutorial", "corruption", {offset=return_coords_from_hex_index(self, first_corruption_hex_pos.x - 1, first_corruption_hex_pos.y) - return_coords_from_hex_index(self, start_hex_pos.x, start_hex_pos.y)})
		end
		for x = 0, boardwidth-1 do
			for y = 0, boardheight-1 do
				if self.board[x][y] and self.board[x][y].id and self.board[x][y].id_group then
					msg.post(msg.url(nil, self.board[x][y].id_group, "sprite"), "play_animation", {id = hash("group_empty")})
				end
			end
		end
		score_calculation(self, hash("none"), hash("none"))
		if coins >= thunder_upgrade_cost then
			msg.post("/gui#main", "is_thunder_upgrade_possible", {possible = true})
		else
			msg.post("/gui#main", "is_thunder_upgrade_possible", {possible = false})
		end
		if snow then
			snow = false
			for x = 0,boardwidth-1 do
				for y = 0,boardheight-1 do
					if self.board[x][y].corrupted then
						local type = unhash[self.board[x][y].tile_type]
						if type == "rock" then
							type = "broken_rock"
						end
						msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("bugged_" .. type)})
					end
				end
			end
		end
		thunder = false
		thunder_active = false
		if stored_delay >= 1 then
			msg.post("/gui#main", "set_asset", {node_id = hash("snow"), anim_id = hash("snowflake")})
		else
			msg.post("/gui#main", "set_asset", {node_id = hash("snow"), anim_id = hash("snowflake_used")})
		end
		if stored_uncorrupt >= 1 then
			msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder")})
		else
			msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder_used")})
		end
		if turn_counter == max_turn then
			sound.stop("/sound")
			msg.post("/end_screen#game_end", "game_won", {triangle_score = triangle_score, village_score = village_score, 
			heal_cell_score = heal_cell_score, village2_score = village2_score, village3_score = village3_score, volume = volume})
		end
		just_created_village = false
		if turn_counter/spawn_village_every_x_turn >= (village_next_id-1) and not village_should_be_created then
			village_should_be_created = true
		end
	elseif message_id == hash("new_tile") then
		message.position.z = 1
		moving_tile_id = factory.create("#hex_factory", camera.window_to_world(hash('/camera'), message["position"]), null, {tile_type = message["type"]})
		moving_tile_offset = message["offset"]
	elseif message_id == hash("update_tile") then
		self.board[message.x][message.y].tile_type = message.new_type
	elseif message_id == hash("reset_game") then
		for x = 0,boardwidth-1 do
			if self.board[x] then
				for y = 0,boardheight-1 do
					if self.board[x][y] then
						if self.board[x][y].id then
							go.delete(self.board[x][y].id)
						elseif self.board[x][y].tile_type then
							go.delete(self.board[x][y].tile_type)
						end
					end
				end
			end
		end
		delay_cost = initial_delay_cost
		uncorrupt_cost = initial_uncorrupt_cost
		stored_thunder = 0
		stored_snow = 0
		thunder_upgrade_cost = 200
		msg.post("/gui#main", "gui_set_thunder_cost", {cost = stored_thunder})
		msg.post("/gui#main", "gui_set_snow_cost", {cost = stored_snow})
		msg.post("/gui#main", "gui_set_thunder_upgrade_cost", {cost = thunder_upgrade_cost})
		msg.post("/gui#main", "set_asset", {node_id = hash("snow"), anim_id = hash("snowflake_used")})
		msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder_used")})
		coins = 0
		coin_income = 0
		corruption_delay = 0
		wood_score = 0
		water_score = 0
		rock_score = 0
		wood_income = 0
		water_income = 0
		rock_income = 0
		bonus_limit = 6
		income = 0
		bonus = 0
		turn_counter = 0
		stats_visibility = false
		triangle_score = 0
		village_score = 0
		heal_cell_score = 0
		village2_score = 0
		village3_score = 0
		self.board = new_board()
		for village_num = 1, #self.villages do
			if self.villages[village_num].id then
				go.delete(self.villages[village_num].id)
			end
		end
		self.villages = {}
		village_count = 0
		village_next_id = 1
		thunder_level = 1
		just_created_village = false
		village_should_be_created = true
		make_possible_moves_around(self, start_hex_pos.x, start_hex_pos.y)
		make_possible_moves_around(self, start_hex_pos.x + 1, start_hex_pos.y)
		score_calculation(self, hash("none"), hash("none"))
		sound.play("/sound#begining_of_game", { delay = 1, gain = theme_sound_gain * volume, pan = -1.0, speed = 1.0} )
	elseif message_id == hash("clear_corruption") then
		clear_corruption(self, true)
	elseif message_id == hash("village_grow") then
		if message["radius_grow"] then 
			grow_bfs(self, message["id"], message["x"], message["y"])
		end
		self.villages[message["id"]].level = message["level"]
	elseif message_id == hash("resource_collected") then
		spawn_resource(self, message["x"], message["y"])
	elseif message_id == hash("income_update") then
		self.villages[message["id"]].income = message["income"]
	elseif message_id == hash("switch_volume") then
		if volume == 1 then 
			volume = 0
			sound.stop("/sound")
		else
			volume = 1
			if turn_counter < corruption_beginning then 
				sound.play("/sound#begining_of_game", { delay = 1, gain = theme_sound_gain * volume, pan = -1.0, speed = 1.0} )
			else
				sound.play("/sound#corruption_appears_theme", { delay = 1, gain = 0.08*volume, pan = -1.0, speed = 1.0} )
			end
		end
	elseif message_id == hash("get_ability") then
		print(message["ability_type"])
		if message["ability_type"] == hash("delay") then
			stored_delay = stored_delay + 1
			msg.post("/gui#main", "gui_set_snow_cost", {cost = stored_delay})
			msg.post("/gui#main", "set_asset", {node_id = hash("snow"), anim_id = hash("snowflake")})
		elseif message["ability_type"] == hash("uncorrupt") then
			stored_uncorrupt = stored_uncorrupt + 1
			msg.post("/gui#main", "gui_set_thunder_cost", {cost = stored_uncorrupt})
			msg.post("/gui#main", "set_asset", {node_id = hash("thunder"), anim_id = hash("thunder")})
		end
	elseif message_id == hash("upgrade_thunder") then
		thunder_level = thunder_level + 1
		coins = coins - thunder_upgrade_cost
		msg.post("/gui#main", "gui_set_coins", {coins = coins})
		thunder_upgrade_cost = thunder_upgrade_cost * 2
		msg.post("/gui#main", "gui_set_thunder_upgrade_cost", {cost = thunder_upgrade_cost})
	end
end

function pick_hex(hex_x, hex_y, x, y)
	local a = 64
	local b = 70
	local t = a * b / (2 * a - b)
	return math.abs(hex_x - x) < a and math.abs(hex_y - y) < a and math.abs(hex_x - x) * a + math.abs(hex_y - y) * (t + a) < a * (t + a)
end

function return_hex_index_from_coords(self, x, y)
	local tmp_y = y - extraheight
	local tmp_x = x - extrawidth
	tmp_y = math.floor(tmp_y/(hex_size*3/4))
	tmp_x = math.floor(tmp_x/(hex_size))
	for i = (tmp_x - 1), tmp_x do
		for j = (tmp_y - 1), tmp_y do
			if i >= 0 and j >= 0 and i <= boardwidth-1 and j <= boardheight-1 then
				if (pick_hex(self.board[i][j].tile_pos_x, self.board[i][j].tile_pos_y, x, y)) then
					return i, j
				end
			end
		end
	end
	return tmp_x, tmp_y
end

local score = 0

function return_coords_from_hex_index(self, x, y)
	local pos = vmath.vector3(0, 0, 0)
	pos.x = 64 + hex_size * x + extrawidth
	pos.y = 64 + 3 * hex_size * y / 4 + extraheight
	if y % 2 == 1 then
		pos.x = pos.x + hex_size / 2
	end
	pos.z = 1 / (y + 3)
	return pos
end

function close_hex_number(self, x, y)
	local close_hex = 0

	local tmp_x, tmp_y
	for i = 1, 6 do
		tmp_x = x + neighbour_sdvig_x[y%2+1][i]
		tmp_y = y + neighbour_sdvig_y[y%2+1][i]
		if check_coord(tmp_x, tmp_y) and self.board[tmp_x][tmp_y].id then
			close_hex = close_hex + 1
		end
	end
	--[[
	if check_coord(x+1, y) and self.board[x+1][y].id then
		close_hex = close_hex + 1
	end
	if check_coord(x-1, y) and self.board[x-1][y].id then
		close_hex = close_hex + 1
	end
	if check_coord(x, y+1) and self.board[x][y+1].id then
		close_hex = close_hex + 1
	end
	if check_coord(x, y-1) and self.board[x][y-1].id then
		close_hex = close_hex + 1
	end
	local sdvig = -1 + (y%2)*2
	if check_coord(x+sdvig, y+1) and self.board[x+sdvig][y+1].id then
		close_hex = close_hex + 1
	end
	if check_coord(x+sdvig, y-1) and self.board[x+sdvig][y-1].id then
		close_hex = close_hex + 1
	end
	]]
	return close_hex
end

function show_hide_moves(self)
	if possible_moves_shown then 
		for x = 0,boardwidth-1 do
			for y = 0,boardheight-1 do
				if check_coord(x, y) and not self.board[x][y].id then
					if not self.board[x][y].possible_move then
						msg.post(msg.url(nil, self.grid[x][y].id, "boundaries"), "make_grey")
					end
				end
			end
		end
	else
		for x = 0,boardwidth-1 do
			for y = 0,boardheight-1 do
				if check_coord(x, y) then
					msg.post(msg.url(nil, self.grid[x][y].id, "boundaries"), "make_light")
				end
			end
		end
	end
end

function make_possible_moves_around(self, x, y)
	local tmp_x, tmp_y
	for i = 1, 6 do
		tmp_x = x + neighbour_sdvig_x[y%2+1][i]
		tmp_y = y + neighbour_sdvig_y[y%2+1][i]
		if check_coord(tmp_x, tmp_y) then
			self.board[tmp_x][tmp_y].possible_move = true
		end
	end
	--[[
	if check_coord(x+1, y) then
		self.board[x+1][y].possible_move = true
	end
	if check_coord(x-1, y) then
		self.board[x-1][y].possible_move = true
	end
	if check_coord(x, y+1) then
		self.board[x][y+1].possible_move = true
	end
	if check_coord(x, y-1) then
		self.board[x][y-1].possible_move = true
	end
	local sdvig = -1 + (y%2)*2
	if check_coord(x+sdvig, y+1) then
		self.board[x+sdvig][y+1].possible_move = true
	end
	if check_coord(x+sdvig, y-1) then
		self.board[x+sdvig][y-1].possible_move = true
	end
	]]
end

function is_for_upgrade(self, x, y, type)
	if type ~= hash("rock") then
		return check_coord(x, y) and self.board[x][y].id and self.board[x][y].tile_type == type 
		and self.board[x][y].structure_direction == nil and self.board[x][y].structure_name == nil
		and not self.board[x][y].corrupted and self.board[x][y].distance_to_village ~= 0
	else
		return check_coord(x, y) and self.board[x][y].id and self.board[x][y].tile_type == type 
		and self.board[x][y].corrupted ~= nil and self.board[x][y].structure_direction == nil
		and self.board[x][y].structure_name == nil and not self.board[x][y].corrupted 
		and self.board[x][y].distance_to_village ~= 0
	end
end

function upgrade_cell(self, x, y, direction, inverted)
	self.board[x][y].structure_direction = direction
	self.board[x][y].structure_name = "triangle"
	timer.delay(0.5, false, function ()
		if not inverted then
			msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("upgraded_" .. unhash[self.board[x][y].tile_type] .. "_" .. direction)})
		else 
			msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash("upgraded_" .. unhash[self.board[x][y].tile_type] .. "_" .. direction .. "_inverted")})
		end
		add_resource_to_villages(self, self.board[x][y].tile_type, x, y)
	end)
	--msg.post(self.board[x][y].id, "upgrade_triangle")
end

function downgrade_cell(self, x, y)
	self.board[x][y].structure_direction = nil
	self.board[x][y].structure_name = nil
	msg.post(msg.url(nil, self.board[x][y].id, "sprite"), "play_animation", {id = hash(self.board[x][y].tile_type)})
	--msg.post(self.board[x][y].id, "downgrade_cell")
	subtract_resource_from_villages(self, self.board[x][y].tile_type, x, y)
end


function is_for_downgrade(self, x, y, type)
	return check_coord(x, y) and self.board[x][y].id and self.board[x][y].tile_type == type 
	and self.board[x][y].structure_direction ~= nil and self.board[x][y].structure_name ~= nil 
end

function delete_triangle(self, x1, y1, x2, y2, x3, y3)
	if self.board[x1][y1].structure_direction ~= nil and self.board[x2][y2].structure_direction ~= nil 
	and self.board[x3][y3].structure_direction ~= nil 
	and self.board[x1][y1].structure_direction ~= self.board[x2][y2].structure_direction
	and self.board[x1][y1].structure_direction ~= self.board[x3][y3].structure_direction 
	and self.board[x2][y2].structure_direction ~= self.board[x3][y3].structure_direction then
		downgrade_cell(self, x1, y1)
		downgrade_cell(self, x2, y2) 
		downgrade_cell(self, x3, y3) 
		msg.post("/sound#sound_gate", "play_gated_sound", {soundcomponent = "/sound#triangle_" .. unhash[self.board[x1][y1].tile_type] .. "_destroyed",  gain = 0.02*volume, delay = 0.2, pan = -1.0, speed = 0.7})
		return true
	end
	return false
end

function destroy_structure(self, x, y)
	if check_coord(x, y) and is_for_downgrade(self, x, y, self.board[x][y].tile_type) then
		for i = 1, 6 do
			if is_for_downgrade(self, x, y, self.board[x][y].tile_type) and
			 is_for_downgrade(self, x + neighbour_sdvig_x[y%2+1][i], y + neighbour_sdvig_y[y%2+1][i], self.board[x][y].tile_type) then
				j = i + 1
				if i == 6 then
					j = 1
				end
				if  is_for_downgrade(self, x + neighbour_sdvig_x[y%2+1][j], y + neighbour_sdvig_y[y%2+1][j], self.board[x][y].tile_type) then
					if delete_triangle(self, x, y, x + neighbour_sdvig_x[y%2+1][i], y + neighbour_sdvig_y[y%2+1][i], x + neighbour_sdvig_x[y%2+1][j], y + neighbour_sdvig_y[y%2+1][j]) then
						do return end
					end	
				end
			end
		end
	end
end

function make_upgrade_structure(self, x, y) 
	-- check triangle structure
	local inverted = false
	local directions = {}
	directions[0] = "left"
	directions[1] = "up"
	directions[2] = "right"
	if check_coord(x, y) and is_for_upgrade(self, x, y, self.board[x][y].tile_type) then
		for i = 1, 6 do
			inverted = not inverted
			if is_for_upgrade(self, x, y, self.board[x][y].tile_type) 
			and is_for_upgrade(self, x + neighbour_sdvig_x[y%2+1][i], y + neighbour_sdvig_y[y%2+1][i], self.board[x][y].tile_type) then
				j = i + 1
				if i == 6 then
					j = 1
				end
				if  is_for_upgrade(self, x + neighbour_sdvig_x[y%2+1][j], y + neighbour_sdvig_y[y%2+1][j], self.board[x][y].tile_type) then
					upgrade_cell(self, x, y, directions[(i - 1) % 3], inverted)
					upgrade_cell(self, x + neighbour_sdvig_x[y%2+1][i], y + neighbour_sdvig_y[y%2+1][i], directions[(i + 1) % 3], inverted) 
					upgrade_cell(self, x + neighbour_sdvig_x[y%2+1][j], y + neighbour_sdvig_y[y%2+1][j], directions[(i) % 3], inverted) 
					msg.post("/sound#sound_gate", "play_gated_sound", {soundcomponent = "/sound#triangle_" .. unhash[self.board[x][y].tile_type] .. "_build",  gain = 0.02*volume, delay = 0.2, pan = -1.0, speed = 0.7})
					triangle_score = triangle_score + 1
					do return end
				end
			end
		end
	end
	-- end of checking triangles (нужно как-то хранить в board структуру в которую входит клетка, 
	--возможно хранить поле струткура с названиями, но это в будущем)
end

function on_input(self, action_id, action)
	local world_pos = camera.window_to_world(hash('/camera'), vmath.vector3(action.x, action.y, 0))
	if action_id == hash("touch_left") and moving_tile_id then
		if action.released then
			local tile_x, tile_y = return_hex_index_from_coords(self, world_pos.x, world_pos.y)
			local moving_tile_url = msg.url(moving_tile_id)
			moving_tile_url.fragment = "tile"
			local tile_type = go.get(moving_tile_url, "tile_type")
			if check_coord(tile_x, tile_y) and not self.board[tile_x][tile_y].id and close_hex_number(self, tile_x, tile_y) > 0 then
				placed_on_tile(self, tile_x, tile_y)
				local pos = return_coords_from_hex_index(self, tile_x, tile_y)
				go.animate(moving_tile_id, "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_LINEAR, 0.4)
				self.board[tile_x][tile_y] = {id = moving_tile_id, x = tile_x, y = tile_y, tile_pos_x = pos.x, tile_pos_y = pos.y, tile_type = tile_type, corrupted = false, possible_move = true,
				distance_to_village = self.board[tile_x][tile_y].distance_to_village, village_center_x = self.board[tile_x][tile_y].village_center_x, 
				village_center_y = self.board[tile_x][tile_y].village_center_y, village_num = self.board[tile_x][tile_y].village_num, structure_direction = nil, structure_name = nil}
				msg.post("#", "next_turn", {tile_type = tile_type, x = tile_x, y = tile_y})
				msg.post("/gui#main", "gui_new_tile")
				--[[
				if stats_visibility then
					msg.post(msg.url(nil, self.board[tile_x][tile_y].id, "tile"), "change_stats_visibility")
				end
				]]--
				make_possible_moves_around(self, tile_x, tile_y)
			else
				go.delete(moving_tile_id)
				msg.post("/gui#main", "gui_revert_tile", {tile_type=tile_type})
			end
			moving_tile_id = nil
			possible_moves_shown = false
			show_hide_moves(self)
		else
			world_pos.z = 0.5
			go.set_position(world_pos - moving_tile_offset, moving_tile_id)
			local tile_x, tile_y = return_hex_index_from_coords(self, world_pos.x, world_pos.y)
			if (pointed_to_tile_x ~= tile_x or pointed_to_tile_y ~= tile_y) and check_coord(tile_x, tile_y) then
				if self.board[tile_x][tile_y].possible_move and not self.board[tile_x][tile_y].id then
					if self.board[pointed_to_tile_x][pointed_to_tile_y].possible_move then
						msg.post(msg.url(nil, self.grid[pointed_to_tile_x][pointed_to_tile_y].id, "boundaries"), "make_light")
					end
					pointed_to_tile_x = tile_x
					pointed_to_tile_y = tile_y
					msg.post(msg.url(nil, self.grid[tile_x][tile_y].id, "boundaries"), "make_blue")
				elseif self.board[pointed_to_tile_x][pointed_to_tile_y].possible_move then
					msg.post(msg.url(nil, self.grid[pointed_to_tile_x][pointed_to_tile_y].id, "boundaries"), "make_light")
					pointed_to_tile_x = tile_x
					pointed_to_tile_y = tile_y
				end
			end
			if not possible_moves_shown then
				possible_moves_shown = true
				show_hide_moves(self)
			end
		end
		if thunder_active then
			thunder_active = false
			msg.post("/gui#main", "thunder_not_used", {still_can_do = true})
			msg.post("/cursor#cursor", "thunder_not_used", {action = "grab"})
		end
		return true
	end
	
	if action_id == hash("touch_left") and action.released then
		local tile_x, tile_y = return_hex_index_from_coords(self, world_pos.x, world_pos.y)
		if check_coord(tile_x, tile_y) and self.board[tile_x][tile_y].distance_to_village == 0 then
			msg.post(msg.url(nil, self.villages[self.board[tile_x][tile_y].village_num].id , "village"), "change_stats_visibility")
		end
	end

	if thunder_active then
		local tile_x, tile_y = return_hex_index_from_coords(self, world_pos.x, world_pos.y)
		local pos = return_coords_from_hex_index(self, tile_x, tile_y)
		pos.z = 0.9
		go.set("/thunder_area", "position", pos)
	end
	if thunder_active and action_id == hash("touch_left") and action.pressed then
		thunder_active = false
		local tile_x, tile_y = return_hex_index_from_coords(self, world_pos.x, world_pos.y)
		local successful_use = thunder_usage(self, tile_x, tile_y)
		if successful_use then
			msg.post("/gui#main", "thunder_been_used")
			msg.post("/cursor#cursor", "thunder_been_used")
			msg.post("/sound#sound_gate", "play_gated_sound", {soundcomponent = "/sound#thunder",  gain = 0.01*volume, delay = 0.2, pan = -1.0, speed = 0.7})
		else
			msg.post("/gui#main", "thunder_not_used", {still_can_do = true})
			msg.post("/cursor#cursor", "thunder_not_used", {action = "grab"})
		end
		return true
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
