local hex_size = 0 
local boardwidth = 0
local boardheight = 0
local extrawidth = 0
local extraheight = 0 
local map_type = "hex"
local pos = vmath.vector3(0,0,0)
local x = 4
local y = 4
local relative_position_down = true   -- false = relative_position_right and down 
local previous = vmath.vector({4, 4})
local can_move = true

function init(self)
	--msg.post("#", "init_vals")
	msg.post("#sprite", "play_animation", { id = hash("rock") })
	--[[
	timer.delay(10, false, function ()
		can_move = false
	end)
	]]
end

function local_check_coord(x, y)
	if map_type == hash("hex") then
		-- looks a bit like hex(octagon actually, but we need more height), requires some rework, but you get the idea
		if (x >= boardwidth or x < 0 or y < 0 or y >= boardheight or
		x + y < 3 or math.abs(boardwidth - 1 - x) + y < 3 or
		x + math.abs(boardheight - 1 - y) < 3 or math.abs(boardwidth - 1 - x) + math.abs(boardheight - 1 - y) < 3 or 
		(y%2 == 0 and x == 0) or (y%2 == 1 and x == 9)) and
		not (x == 0 and y == 4) and 
		not (x == 1 and y == 1) and 
		not (x == 2 and y == 0) and 
		not (x == 1 and y == 7) and 
		not (x == 2 and y == 8) and 
		not (x == 7 and y == 8) and 
		not (x == 7 and y == 0)
		then
			return false
		end
		return true
	else
		if (x >= boardwidth or x < 0 or y < 0 or y >= boardheight) then
			return false
		end
		return true
	end
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function local_return_coords_from_hex_index(self, x, y)
	local pos = vmath.vector3(0, 0, 0)
	pos.x = 64+hex_size*x +extrawidth
	pos.y = 64+3*hex_size*y/4 +extraheight
	if y%2==1 then
		pos.x = pos.x + hex_size/2
	end
	pos.z = 1 / (y + 3)
	return pos
end

function on_message(self, message_id, message, sender)
	if message_id == hash("init_vals") then 
		hex_size = go.get("/game#board", "hex_size")
		boardwidth = go.get("/game#board", "boardwidth")
		boardheight = go.get("/game#board", "boardheight")
		extrawidth = go.get("/game#board", "extrawidth")
		extraheight = go.get("/game#board", "extraheight")
		map_type = go.get("/game#board", "map_type")

		timer.delay(2, false, function ()
			msg.post("#", "move")
		end)
	elseif message_id == hash("move") then 
		can_move = true
		local x_y_index_vec = vmath.vector()
		local possible_next = {}
		
		if previous[1] ~= x or previous[2] ~= y then
			table.insert(possible_next, vmath.vector({x,y}))
		end
		if relative_position_down then
			if previous[1] ~= x-1 or previous[2] ~= y and local_check_coord(x-1,y) then
				table.insert(possible_next, vmath.vector({x-1,y}))
			end
			if previous[1] ~= x+(y%2)-1 or previous[2] ~= y-1 and local_check_coord(x+(y%2)-1, y-1) then
				table.insert(possible_next, vmath.vector({x+(y%2)-1, y-1}))
			end
		else
			if previous[1] ~= x+1 or previous[2] ~= y and local_check_coord(x+1,y) then
				table.insert(possible_next, vmath.vector({x+1,y}))
			end
			if previous[1] ~= x+(y%2) or previous[2] ~= y+1 and local_check_coord(x+(y%2), y+1) then
				table.insert(possible_next, vmath.vector({x+(y%2), y+1}))
			end
		end
		
		math.randomseed(os.clock())
		local random_pick = (math.random(#possible_next) + math.random(#possible_next)) % (#possible_next) + 1
		x_y_index_vec = possible_next[random_pick]
		
		previous[1] = x
		previous[2] = y
		x = x_y_index_vec[1]
		y = x_y_index_vec[2]

		relative_position_down = not relative_position_down
		
		pos.x = 64 + hex_size * x + extrawidth
		pos.y = 64 + 3 * hex_size * y / 4+ extraheight

		if y%2==1 then
			pos.x = pos.x + hex_size/2
		end

		if not relative_position_down then
			pos.x = pos.x + hex_size/2
			pos.y = pos.y - hex_size/4
		else
			pos.y = pos.y - hex_size/2
		end
		go.animate("/traveller", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_LINEAR, 0.5)
		
		timer.delay(1, false, function ()
			if can_move then
				msg.post("#", "move")
			end
		end)
	elseif message_id == hash("stop") then 
		can_move = false
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
